[
  {
    "objectID": "project1.html",
    "href": "project1.html",
    "title": "ST-558 Project 1",
    "section": "",
    "text": "Preprocessing\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.4     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(httr)\nlibrary(rjson)\nlibrary(ggplot2)\nlibrary(quantreg)\n\nLoading required package: SparseM\n\n\n\n\nThe usual process to work with a given URL.\nThis code is simply a proof of concept query of the PUMS Census API. Variables are set for the necessary API inputs which are then used to construct an URL to query cenus.gov. The httr::GET() function contains query and for arguments which receptively take in PUMS API variables and geographic region as inputs to finalize the URL and return an http response object. This object can be further be parsed to extract the raw character data from the query.\n\nvariables &lt;- c(\"PWGTP\",\"AGEP\",\"SEX\", \"FER\", \"JWTRNS\")\ngeography &lt;- \"state:01\"\nyear &lt;- \"2022\"\nurl &lt;- paste0(\"https://api.census.gov/data/\", year, \"/acs/acs1/pums?\")\nres &lt;- GET(url, query = list(get=paste(variables, collapse=\",\"), `for`=geography))\n\n\n\nHelper function to take what is returned by GET() and turn it into a nice tibble.\nThe function get_pums_tibble takes in an http response object returned from httr::GET(), extracts the raw character data using httr::content, and parses it into a formatted tibble, which is finally returned. The process is given below:\n\nParses the HTML content with httr::content.\n\nEach row of raw html text is returned as a list within a list. Each element must be unlisted into a list of vectors.\n\nThe list is converted into a data frame for easier manipulation. However, each row of raw html text becomes a column instead of a row in the data frame. The column names being text row numbers serve no purpose other than more readable output for debugging.\n\nThe data frame is converted into a matrix for an easier transpose operation. Transposing the matrix takes each observation represented as a column and transforms it into a row. Once the matrix is transformed into a standard format, it’s converted into a tibble.\n\nThe variable names are stored in the first row. The first row is set as the column names and then dropped.\n\nThe formatted tibble is returned.\n\n\nget_pums_tibble &lt;- function(html_page) {\n    content &lt;- content(html_page, as=\"parsed\") #\n    content &lt;- lapply(content, unlist) |&gt; \n                as.data.frame(col.names=1:length(content)) |&gt; \n                as.matrix() |&gt; t() |&gt; as_tibble()\n    content &lt;- content |&gt; setNames(content[1,]) |&gt; slice(-1)\n    return(content)\n}\n\n\n\nData Processing\nThis code block pulls a list of state codes from census.gov needed to check whether the user specified state code is correct. On census.gov the variable key appears to only exist for 2021 or later, but the same codes seem to work.\n\n# Needed for checking valid state codes\nst_codes &lt;- fromJSON(paste(readLines(\"https://api.census.gov/data/2022/acs/acs1/pums/variables/ST.json\"), collapse=\"\"))$values$item |&gt; names()\n\nWarning in\nreadLines(\"https://api.census.gov/data/2022/acs/acs1/pums/variables/ST.json\"):\nincomplete final line found on\n'https://api.census.gov/data/2022/acs/acs1/pums/variables/ST.json'\n\n\n\n\nSingle Year Function\nThe function get_single_year() is for parsing a single year of census data from census.gov using the PUMS API according to user specified numerical and categorical variables, the year, and a geographical subset of the data by region, division, or state.\nThe first 50 lines of code in get_single_year() are for validating user input for year, numeric variables, categorical variables, geography subset, and geography level. If any of these inputs are not the correct data type, undefined options according to the project requirements, or disallowed combinations of variables, then an appropriate error will be thrown. Many values for the correct function arguments are hard coded included geography levels except the state codes. Finally since variables change from year to year, all user supplied variables will be checked if they exist for that given year. If all variables exist the query will proceed, otherwise a warning lets the user know which variables aren’t present during that year and an empty tibble is returned.\nOnce user input is validated, a URL string must be formatted to query the PUMS API. First, a string represented the geography subset is formatted, which is then concatenated with the other components of the URL. Then, the httr:GET function queries cenus.gov using the query and for arguments to finalized the URL string and return an http response object. Next, get_pums_tibble() processes the http object and returns a tibble with the parsed census data stored within.\nThe bulk of the code in get_single_year contains logic for finding the midpoint of JWDP and JWAP and converting it into HH:MM:SS format with the hms package. However, these variables are factors corresponding to time ranges represented as strings in a non-standard format. So, first the variable descriptions must be pulled from census.gov and converted into a map to decode the raw data. However, this revealed another issue where the key in the key-value pairs mapping the factor to its description all have a length of 3. So, the raw data needs to be padded to match the variable description keys. The resulting process to decode the data follows these steps:\n\nPad raw data with zeros on the left to a maximum length of 3.\nConstruct the URL to download the JWDP code mapping for the specified year.\nDownloads and reads the JSON file, extracts the mapping of JWDP codes to time ranges, and convert to a list.\nRenames the mapping key “0” to “000” to match the padded JWDP raw data.\nLoop over each row/observation in the tibble\n\nIf the JWDP code is “000” (which means “Not applicable”), sets it to NA.\nOtherwise, splits the mapped time range (e.g., “5:00 a.m. to 5:29 a.m.”) into start and end times, removes periods, and converts all characters to uppercase.\nParses the start and end times, converts them to numeric (seconds or minutes), and calculates the midpoint.\nAssigns the midpoint value back to the JWDP column for that row.\nConverts the JWDP column to numeric values (the tibble coerces it back to a character).\nConverts the JWDP column to HMS (hour-minute-second) time format.\nRemoves “JWDP” from the num_vars vector, since it is no longer a numeric variable.\n\n\nThis approach is likely more complicated than it needs to be, but it was the first solution we developed. One major issue with this approach is the for loop which is inherently slower in an interpreted language like R, especially when multiple complex statements are nested within. In production, this code should be rewritten for optimization. The same process is followed for both JWDP and JWAP.\nThe final portion of get_single_year() converts all categorical variables into factors with labels pulled from the official variable descriptions queried from census.gov. The process of converting the categorical variables into factors with levels is as follows:\n\nIterates through each variable in the vector cat_vars.\nConstructs the URL to download the JSON variable map for the current variable and year.\nDownloads the JSON file, reads it as a single string, parse it, and extracts the mapping of codes to labels for the variable.\nRemoves leading zeros from the code names (except for the value “0”), so that codes in the data (which may not have leading zeros) will match the JSON map keys.\nConverts the column df[[variable]] (for each cat_var) into a factor, using the cleaned names as levels and the corresponding labels from the map as the factor labels.\n\nLast, the remaining numeric variables are converted from character to numeric and the tibble is returned. Note there is no data for 2020.\n\nget_single_year &lt;- function(year = 2022, num_vars = c(\"AGEP\", \"PWGTP\"), \n                            cat_vars = c(\"SEX\"), geography = \"State\", geography_level = c(\":13\")) {\n    # Validate Survey Year\n    if (!is.numeric(year)) {\n        stop(\"Year must be numeric\")\n    } \n    if (!(year %in% c(2010:2019, 2021:2022))) {\n        stop(\"Year must be between 2010 and 2019 or 2021, 2022\")\n    }\n    # Validate Numeric Variables\n    if (!(\"PWGTP\" %in% num_vars)) {\n        stop(\"PWGTP must be included in the numeric variables\")\n    }\n    if (length(num_vars) &lt; 2) {\n        stop(\"At least one numeric variable besides PWGTP is required\")\n    }\n    if (!all(num_vars %in% \n             c(\"AGEP\",\"GASP\",\"GRPIP\",\"JWAP\",\"JWDP\",\"JWMNP\",\"PWGTP\"))) {\n        stop(\"Undefined numeric variable(s)\")\n    }\n    # Validate Categorical Variables\n    if (length(cat_vars) == 0) {\n        stop(\"At least one categorical variable required\")\n    }\n    if (!all(cat_vars %in% c(\"FER\", \"HHL\", \"HISPEED\", \"JWTRNS\", \"SCH\", \"SCHL\", \"SEX\"))) {\n        stop(\"Undefined categorical variable(s)\")\n    }\n    # Validate Region Variable\n    if (!(geography %in% c(\"State\", \"Division\", \"Region\"))) {\n        stop(\"Geography must be 'Region', 'Division' or 'State'\")\n    }\n    # Validate Geography Level\n    if (geography == \"State\" && (geography_level %in% st_codes) == FALSE) {\n        stop(\"Invalid State value. Find defined state codes at\n             https://api.census.gov/data/2022/acs/acs1/pums/variables/ST.json\")\n    } \n    else if (geography == \"Division\" && (as.numeric(geography_level) %in% 1:9) == FALSE) {\n        stop(\"Valid Division values are between 1 and 9\")\n    }\n    else if (geography == \"Region\" && (as.numeric(geography_level) %in% 1:4 == FALSE)) {\n        stop(\"Valid Region values are between 1 and 4\")\n    }\n    \n    #Check if variables are present in selected year\n    all_vars &lt;- paste0(\"https://api.census.gov/data/\", as.character(year), \"/acs/acs1/pums/variables\") |&gt;\n        GET() |&gt; content(as=\"parsed\") |&gt; tail(-1) |&gt; lapply(`[[`, 1) |&gt; unlist()\n    \n    if (!all(c(num_vars, cat_vars) %in% all_vars)) {\n        warning(paste(\"The following variables: (\",\n                      setdiff(c(num_vars, cat_vars), all_vars),\n                      \") are undefined for year\",\n                      as.character(year), sep = \" \"))\n        return(tibble())\n    }\n\n    #Create geography argument for the query\n    geography &lt;- paste0(geography, \":\", paste(geography_level, collapse = \",\"))\n     \n    url &lt;- paste0(\"https://api.census.gov/data/\", as.character(year), \"/acs/acs1/pums?\")\n    res &lt;- GET(url, query = list(get=paste(c(num_vars, cat_vars), collapse=\",\"), `for`=geography))\n    \n    \n    df &lt;- get_pums_tibble(res)\n\n    # Convert Journey to Work Departure Time to HH:MM Format\n    if (\"JWDP\" %in% num_vars && \"JWDP\" %in% names(df)) {\n        \n        df &lt;- df |&gt; mutate(JWDP = str_pad(JWDP, width = 3, side = \"left\", pad = \"0\"))\n        jwdp_file &lt;- paste0(\"https://api.census.gov/data/\", as.character(year),\n                                \"/acs/acs1/pums/variables/JWDP.json\")\n        jwdp_map &lt;- fromJSON(paste(readLines(jwdp_file), collapse=\"\"))$values$item |&gt; as.list()\n\n        names(jwdp_map)[names(jwdp_map) == \"0\"] &lt;- \"000\"\n\n        for (i in 1:nrow(df)) {\n            if (df$JWDP[i] == \"000\") {\n                df$JWDP[i] &lt;- NA\n            } else {\n                iv &lt;- strsplit(jwdp_map[[ df$JWDP[i] ]], \" to \")[[1]] |&gt; str_remove_all(\"\\\\.\") |&gt; \n                    str_to_upper()\n                mid &lt;- ((as.numeric(parse_time(iv[2])) + as.numeric(parse_time(iv[1])) ) / 2)\n                df$JWDP[i] &lt;- mid\n            }\n        }\n        df &lt;- df |&gt; mutate(JWDP = hms::as_hms(as.numeric(JWDP)))\n        num_vars &lt;- num_vars[num_vars != \"JWDP\"]\n    }\n    \n    # Convert Journey to Work Arrival Time to HH:MM Format\n    if (\"JWAP\" %in% num_vars && \"JWAP\" %in% names(df)) {\n    df &lt;- df |&gt; mutate(JWAP = str_pad(JWAP, width = 3, side = \"left\", pad = \"0\"))\n\n        jwap_file &lt;- paste0(\"https://api.census.gov/data/\", as.character(year),\n                            \"/acs/acs1/pums/variables/JWAP.json\")\n        jwap_map &lt;- fromJSON(paste(readLines(jwap_file), collapse=\"\"))$values$item |&gt; as.list()\n\n        names(jwap_map)[names(jwap_map) == \"0\"] &lt;- \"000\"\n\n        for (i in 1:nrow(df)) {\n            if (df$JWAP[i] == \"000\") {\n                df$JWAP[i] &lt;- NA\n            } else {\n                iv &lt;- strsplit(jwap_map[[ df$JWAP[i] ]], \" to \")[[1]] |&gt; str_remove_all(\"\\\\.\") |&gt; \n                    str_to_upper()\n                mid &lt;- ((as.numeric(parse_time(iv[2])) + as.numeric(parse_time(iv[1])) ) / 2)\n                df$JWAP[i] &lt;- mid\n            }\n        }\n        df &lt;- df |&gt; mutate(JWAP = hms::as_hms(as.numeric(JWAP)))\n        num_vars &lt;- num_vars[num_vars != \"JWAP\"]\n    }\n    \n    # Convert Categorical Variables into Factors with Levels\n    for (variable in cat_vars) {\n        var_url &lt;- paste0(\"https://api.census.gov/data/\", year, \"/acs/acs1/pums/variables/\", variable, \".json\")\n        var_map &lt;- fromJSON(paste(readLines(var_url), collapse=\"\"))$values$item\n        names(var_map) &lt;- str_replace(names(var_map), \"^0+(?!$)\", \"\")\n        df[[variable]] &lt;- factor(df[[variable]], levels = names(var_map), labels = unlist(unname(var_map)))\n    }\n    # Convert Numeric Variables to Numeric\n    df &lt;- df |&gt; mutate(across(all_of(num_vars), ~ as.numeric(.)))\n    \n    return(df)\n}\n\n\n\nMulti-Year Function\nThe get_multi_years() function takes in the same arguments as get_single_year with one exception, year is a vector of numbers rather than a single number. First lapply() iterates over the years vector calling get_single_year() for each element which returns a list of tibbles, one for each year. mutate(.x, year = .y) is used inside map2_dfr() to add a new column called year to each tibble .x, setting its value to .y (the corresponding year)..x is the current tibble (data for one year). .y is the current year from the years vector.map2_dfr() then binds all the tibbles together row-wise into a single tibble.\n\nget_multi_years &lt;- function(years = c(2022), num_vars = c(\"AGEP\", \"PWGTP\"),\n                            cat_vars = c(\"SEX\"), geography = \"State\", geography_level = c(\"13\")) {\n    myear_tibble &lt;- lapply(years, function(y) \n        get_single_year(y, num_vars, cat_vars, geography, geography_level)) |&gt; \n        map2_dfr(years, ~ mutate(.x, year = .y))\n    return(myear_tibble)\n}\n\n\n\nGeneric Function for Summarizing\nThis method belongs to the census class which is an object of type tibble() returned from a call from either get_single_year() or get_multi_year(). This method will specify the behavior of the generic function summary() uniquely for a census object. The function arguments take in a census tibble and optional vectors of numeric and categorical variables. By default, the weighted means and standard deviations of all numeric variables and the weighted counts of all categorical variables will be returned. However, if the user specifies a vector of numeric or categorical variables in the function call, only summaries of those variables will be returned. PWGTP being a frequency count per household will not be summarized and will act as the weight for the means, standard deviations, and overall counts for each level of the categorical variables.\nThe summarize() function is used across all numeric variables excepting PWGTP with the provided weighted mean and standard deviation formulas. The resulting summary statistic is named according to the column being summarized. The categorical variables are counted my mapping the list of categorical variables to a function which first takes the data tibble. The function groups the tibble by each categorical one at a time, before summarize() adds a new variable called Freq by summing PWGTP from all observations for a given category level. The numeric summary tibbles are bound together with a row for each summary statistic, in this case two, and a column for each numeric variable summarized. This numeric summary tibble and the frequency tibbles are finally returned as a list.\n\nsummary.census &lt;- function(tibble, num_vars = NULL, cat_vars = NULL) {\n    # Tibbles to store output\n    mean_tibble &lt;- sd_tibble &lt;- freq_tibbles &lt;- NULL\n    # Drop year if present since it's summary isn't needed\n    tibble &lt;- tibble |&gt; select(-any_of(\"year\"))\n    # Check if numeric variables are specified\n    if (!is.null(num_vars)) {\n        mean_tibble &lt;- tibble |&gt; summarize(across(all_of(num_vars) & !all_of(\"PWGTP\"),\n                                         ~ sum(.x * PWGTP) / sum(PWGTP), .names = \"{.col}\"))\n        \n        sd_tibble &lt;- tibble |&gt; summarize(across(all_of(num_vars) & !all_of(\"PWGTP\"),\n                        ~ sqrt(sum(.x^2 * PWGTP) / sum(PWGTP) - (sum(.x * PWGTP) / sum(PWGTP))^2 ),\n                        .names = \"{.col}\"))\n    }\n    # Check if categorical variables are specified\n    if(!is.null(cat_vars)) {\n        freq_tibbles &lt;- map(cat_vars,\n                            function(v) {tibble |&gt; group_by(.data[[v]]) |&gt;\n                                    summarize(Freq = sum(PWGTP), .groups = \"drop\")})\n    }\n    # Default - return summaries of all numeric and counts of all categorical\n    if (is.null(num_vars) && is.null(cat_vars)) {\n\n        mean_tibble &lt;- tibble |&gt; summarize(across(where(is.numeric) & !all_of(\"PWGTP\"),\n                                             ~ sum(.x * PWGTP) / sum(PWGTP), .names = \"{.col}\"))\n            \n        sd_tibble &lt;- tibble |&gt; summarize(across(where(is.numeric) & !all_of(\"PWGTP\"),\n                            ~ sqrt( sum(.x^2 * PWGTP) / sum(PWGTP) - (sum(.x * PWGTP) / sum(PWGTP))^2 ),\n                            .names = \"{.col}\")) \n        \n        cat_vars &lt;- tibble |&gt; select(where(is.factor)) |&gt; names()\n        freq_tibbles &lt;- map(cat_vars,\n                            function(v) {tibble |&gt; group_by(.data[[v]]) |&gt;\n                                    summarize(Freq = sum(PWGTP), .groups = \"drop\")})\n    }\n    \n    stat_tibble &lt;- bind_rows(mean_tibble, sd_tibble) |&gt;\n        mutate(stat = c(\"Mean\", \"Standard Deviation\")) |&gt;\n        select(stat, everything())\n\n    return(list(stat_tibble, freq_tibbles))\n}\n\n\n\nGeneric Function for Plotting\nplot.census is a generic plot() function for a census class tibble. It requires the user to supply arguments for a tibble, one categorical variable and one numeric variables. The plot function uses ggplot, the aesthetic function and geom_boxplot function to create boxplots of the categorical variable levels on the x-axis and the numeric variable on the y-axis.\n\nplot.census &lt;- function(my_tibble, num_var, cat_var) {\n    ggplot(my_tibble,\n           aes(x = get(cat_var), y = get(num_var),\n               weight = PWGTP)) +\n               labs(title = \"Generic Plot Function\", x = cat_var, y = num_var) + \n            geom_boxplot()\n}\n\n\n\nFunction Verification and Objects of Class ‘Census’\nThis code chunk contains code that verifies all functions in this project:\n\nget_single_year, called by syear_test\nget_multi_years, called by myear _test\nsummary.census, called by summary(syear_test) or summary(myear_test)\nplot.census, called by plot(syear_test) or plot(myear_test)\n\nsyear_test calls the single year function with arguments supplied for numeric, categorical, geography and geography level. Year is the default value in the single year function. myear_test calls the multi-year function with arguments supplied for years, numeric, categorical, geography, and geography level.\nsummary(syear_test) and summary(myear_test) calls the generic summary method for objects of type census. plot(syear_test) and plot(myear_test) calls the generic plot method for objects of type census.\nThis section also shows the two statements that are used to create objects of class Census and add this class to the single year tibble (syear_test) and multi-year tibble (myear_test). Both of these objects are type tibble when returned by the single year and multi-year functions.\n\nsyear_test &lt;- get_single_year(num_vars = c(\"PWGTP\",\"AGEP\",\"JWDP\"),\n                       cat_vars = c(\"SEX\", \"JWTRNS\"),\n                       geography = \"State\", geography_level = c(\"02\"))\n\nWarning: The `x` argument of `as_tibble.matrix()` must have unique column names if\n`.name_repair` is omitted as of tibble 2.0.0.\nℹ Using compatibility `.name_repair`.\n\n\nWarning in readLines(jwdp_file): incomplete final line found on\n'https://api.census.gov/data/2022/acs/acs1/pums/variables/JWDP.json'\n\n\nWarning in readLines(var_url): incomplete final line found on\n'https://api.census.gov/data/2022/acs/acs1/pums/variables/SEX.json'\n\n\nWarning in readLines(var_url): incomplete final line found on\n'https://api.census.gov/data/2022/acs/acs1/pums/variables/JWTRNS.json'\n\nmyear_test &lt;- get_multi_years(years = c(2019, 2022), num_vars = c(\"PWGTP\",\"AGEP\",\"JWDP\"),\n                       cat_vars = c(\"SEX\", \"JWTRNS\"),\n                       geography = \"State\", geography_level = c(\"02\"))\n\nWarning in readLines(jwdp_file): incomplete final line found on\n'https://api.census.gov/data/2019/acs/acs1/pums/variables/JWDP.json'\n\n\nWarning in readLines(var_url): incomplete final line found on\n'https://api.census.gov/data/2019/acs/acs1/pums/variables/SEX.json'\n\n\nWarning in readLines(var_url): incomplete final line found on\n'https://api.census.gov/data/2019/acs/acs1/pums/variables/JWTRNS.json'\n\n\nWarning in readLines(jwdp_file): incomplete final line found on\n'https://api.census.gov/data/2022/acs/acs1/pums/variables/JWDP.json'\n\n\nWarning in readLines(var_url): incomplete final line found on\n'https://api.census.gov/data/2022/acs/acs1/pums/variables/SEX.json'\n\n\nWarning in readLines(var_url): incomplete final line found on\n'https://api.census.gov/data/2022/acs/acs1/pums/variables/JWTRNS.json'\n\n#Add Class Census to Single Year Object\nclass(syear_test) &lt;- c(\"census\", class(syear_test))\n\n#Add Class Census to Multi Year Object\nclass(myear_test) &lt;- c(\"census\", class(myear_test))\n    \nsummary(syear_test)\n\n[[1]]\n# A tibble: 2 × 2\n  stat                AGEP\n  &lt;chr&gt;              &lt;dbl&gt;\n1 Mean                37.0\n2 Standard Deviation  22.2\n\n[[2]]\n[[2]][[1]]\n# A tibble: 2 × 2\n  SEX      Freq\n  &lt;fct&gt;   &lt;dbl&gt;\n1 Male   387793\n2 Female 345790\n\n[[2]][[2]]\n# A tibble: 10 × 2\n   JWTRNS                                                                   Freq\n   &lt;fct&gt;                                                                   &lt;dbl&gt;\n 1 Worked from home                                                        35036\n 2 Taxicab                                                                  1909\n 3 Bus                                                                      6498\n 4 N/A (not a worker-not in the labor force, including persons under 16 … 379267\n 5 Other method                                                            13981\n 6 Bicycle                                                                   719\n 7 Car, truck, or van                                                     269752\n 8 Ferryboat                                                                 132\n 9 Walked                                                                  25281\n10 Motorcycle                                                               1008\n\nsummary(myear_test)\n\n[[1]]\n# A tibble: 2 × 2\n  stat                AGEP\n  &lt;chr&gt;              &lt;dbl&gt;\n1 Mean                36.7\n2 Standard Deviation  22.2\n\n[[2]]\n[[2]][[1]]\n# A tibble: 2 × 2\n  SEX      Freq\n  &lt;fct&gt;   &lt;dbl&gt;\n1 Male   766269\n2 Female 698859\n\n[[2]][[2]]\n# A tibble: 10 × 2\n   JWTRNS                                                                   Freq\n   &lt;fct&gt;                                                                   &lt;dbl&gt;\n 1 Worked from home                                                        48366\n 2 Taxicab                                                                  2588\n 3 Bus                                                                      9604\n 4 N/A (not a worker-not in the labor force, including persons under 16 … 766629\n 5 Other method                                                            26395\n 6 Bicycle                                                                  3170\n 7 Car, truck, or van                                                     556684\n 8 Walked                                                                  50377\n 9 Ferryboat                                                                 262\n10 Motorcycle                                                               1053\n\nplot(syear_test, cat_var = \"SEX\", num_var = \"AGEP\" )\n\n\n\n\n\n\n\nplot(myear_test, cat_var = \"JWTRNS\", num_var = \"AGEP\")\n\n\n\n\n\n\n\n\n\n\nInvestigation (Research Question)\nIs there a difference between SEX for Gross Rent as Percent of household income over past 12 months (GASP) for Georgia Residents in 2021 and 2022?\n\ngeorgia_2122 &lt;- get_multi_years(years = c(2021, 2022), num_vars = c(\"PWGTP\",\"GASP\"),\n                       cat_vars = c(\"SEX\"),\n                       geography = \"State\", geography_level = c(\"13\"))\n\nWarning in readLines(var_url): incomplete final line found on\n'https://api.census.gov/data/2021/acs/acs1/pums/variables/SEX.json'\n\n\nWarning in readLines(var_url): incomplete final line found on\n'https://api.census.gov/data/2022/acs/acs1/pums/variables/SEX.json'\n\nclass(georgia_2122) &lt;- c(\"census\", class(georgia_2122))\n\nsummary(georgia_2122, num_vars = \"GASP\", cat_vars = \"SEX\")\n\n[[1]]\n# A tibble: 2 × 2\n  stat                GASP\n  &lt;chr&gt;              &lt;dbl&gt;\n1 Mean                58.0\n2 Standard Deviation 116. \n\n[[2]]\n[[2]][[1]]\n# A tibble: 2 × 2\n  SEX        Freq\n  &lt;fct&gt;     &lt;dbl&gt;\n1 Male   10590186\n2 Female 11122256\n\n# Research Question Plots \n\n#Plot 1 - Generic Plot Function\nplot(georgia_2122, num_var = \"GASP\", cat_var = \"SEX\")\n\n\n\n\n\n\n\n#Plot 2 - Generic Plot Function with Outliers Removed\ngeorgia_2122 |&gt; ggplot(aes(x = SEX, y = GASP,\n                weight = PWGTP)) +\n                labs(title = \"Generic Plot with Outliers Removed\", x = \"SEX\", y = \"GASP\") +\n                geom_boxplot(outlier.shape = NA)\n\n\n\n\n\n\n\n#Plot 3 - Generic Plot Function with Range y = 0 - 250\ngeorgia_2122 |&gt; ggplot(aes(x = SEX, y = GASP,\n                weight = PWGTP)) +\n                labs(title = \"Generic Plot with Focus on IQR\", \n                     x = \"SEX\", y = \"GASP\") +\n                    geom_boxplot() +\n                    coord_cartesian(ylim = c(0, 250))\n\n\n\n\n\n\n\n#Plot 4 - Generic Plot Function with Range y = 0 - 50 \ngeorgia_2122 |&gt; ggplot(aes(x = SEX, y = GASP,\n                weight = PWGTP)) +\n                labs(title = \"Generic Plot with Focus on Median\", \n                     x = \"SEX\", y = \"GASP\") +\n                    geom_boxplot() +\n                    coord_cartesian(ylim = c(0, 50))\n\n\n\n\n\n\n\n\nSummary of Research\nIn order to answer the research question, we first tried the generic plot function for GASP vs. SEX (see Plot #1 in code chunk above). From inspection of this plot, we can see that the data is highly right skewed numeric data. The skewness distorts the axis for the numeric variable of interest (GASP), and as a result, the plot does not provide useful information.\nIn order to address this limitation, we took the generic plotting function outside of the function and made three (3) different plots to get to a useful result:\n\nFirst, we removed outliers to determine the effect on the range of GASP (see Plot #2 in Research Question code chunk above). With outliers were removed, we were still unable to determine the shape of the distribution around the highest density interval, represented by the Inter-Quartile Range (IQR).\nSecond, we zoomed in on the Box and Whiskers. We were still unable to determine if there was a meaningful difference between males and females (see Plot #3 in Research Question code chunk) Note that the IQR for this plot is the same but the medians are different.\nFinally, we generated a third box plot, zooming in on the median. Here, we see that the median GASP for females is approximately 20, while the median GASP for males is approximately 3 (see Plot #4 in code chunk above).\n\nConclusion on Research\nThis suggests that the distributions of GASP between males and females are similar in shape, especially in the tails, but the center of the distributions appear to be different. Whether or not this is a meaningful difference we cannot tell without numerical methods that quantify variability beyond the capabilities of the boxplot.\nQuestionable Content\nFrom Single Year Function Text\nThe get_single_year() function itself is too long and ideally would be split into 3 additonal functions. One for validating and formatting user input. A second for calculating the midpoint of the time ranges in JWDP and JWAP before converting them into an R time format. Finally, a third function for converting all the categorical variables into factors with appropriate labels pulled from census.gov’s variable descriptions. However, the project didn’t require this, so the code will be left in a monolithic format.\nFrom Research Question Text\nFrom the results of our research on the question of interest, we conclude that the generic summary and plot functions are limited because we cannot supply ggplot options, filtering and selection statements. Therefore, the generic functions are not particularly useful to answer research questions on the data. The functions are useful for proof of concept, showing we understand how to create class methods, but not useful for exploratory data analysis."
  }
]